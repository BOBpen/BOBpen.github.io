<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        堆基础笔记 · BOBpenのStudio
        
    </title>
    <link rel="icon" href= /assests/favicon.ico>
    <!-- 提前加载place holder  -->
    <style>
        @font-face {
            font-family: 'Oswald-Regular';
            src: url('/font/Oswald-Regular.ttf');
        }
        @font-face {
            font-family: 'Source Sans Pro';
            src: url('/font/Source Sans Pro.woff'),
            url('/font/Source Sans Pro.woff2');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'Source Code Pro';
            src: url('/font/SourceCodePro-Regular.ttf.woff'),
            url('/font/SourceCodePro-Regular.ttf.woff2');
            font-weight: normal;
            font-style: normal;
        }
        
        
        .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0px;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        99% {
            transform: translate3d(0, 0, 0);
        }
        99.1% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(-226px, 0, 0);
        }
    }
    </style>
    <link rel="stylesheet" href = /css/style.css?v=20171005 />
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>
    
        <body class="post-body">
    
    
<header class="header">

    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >BOBpenのStudio.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">堆基础笔记</a>
            </div>
    </div>
    
    <a class="home-link" href=/>BOBpenのStudio.</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-img" style="background-image: url(http://oumn0o088.bkt.clouddn.com/post-bg.jpg)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            堆基础笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
        </p>
        <!-- 404 -->
        
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2018/01/25</span>
            </div>
        
    </div>
</div>
        <div class="container">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="linux虚拟内存"><a href="#linux虚拟内存" class="headerlink" title="linux虚拟内存"></a>linux虚拟内存</h2><p><img src="https://ctf-wiki.github.io/ctf-wiki/_images/program_virtual_address_memory_space.png" alt=""></p>
<ul>
<li>与下图对应</li>
</ul>
<p><img src="http://www.linuxidc.com/upload/2015_02/150225122528321.png" alt=""> </p>
<p>问题：</p>
<p>计算机明明没有那么多内存（n个进程的话就需要n*4G）内存</p>
<p>建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！</p>
<ol>
<li><p>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址</p>
</li>
<li><p>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</p>
</li>
<li><p>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</p>
</li>
<li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li>
<li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常</li>
<li>缺页异常的处理过程，就是把进程</li>
<li>需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘</li>
</ol>
<p><a href="http://www.linuxidc.com/Linux/2015-02/113981.htm" target="_blank" rel="external"><strong>虚拟内存和物理内存的映射</strong></a></p>
<h2 id="Linux堆"><a href="#Linux堆" class="headerlink" title="Linux堆"></a>Linux堆</h2><blockquote>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/heap_basic_intro.html" target="_blank" rel="external"><strong>堆的基本操作</strong></a></p>
<p><a href="http://www.cnblogs.com/alisecurity/p/5486458.html" target="_blank" rel="external"><strong>堆内存管理</strong></a></p>
<ol>
<li>系统调用：<strong>sbrk（brk）</strong> 和 <strong>mmap</strong> 和 <strong>多线程</strong></li>
<li>虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，加快了程序的效率。<strong>我们称这一块连续的内存区域为arena。</strong>此外，由于这块内存是由<strong>主线程</strong>申请的，所以我们称之为<strong>main_arena</strong>。对于后续的申请的内存会一直从这个arena中获取，直到空间不足。当出现arena空间不足时，<strong>它可以通过增加brk的方式来增加堆的空间。类似地，arena也可以通过减小brk来缩小自己的空间</strong>。</li>
<li>当不开启ASLR保护时，start_brk以及brk会指向data/bss 段的结尾。</li>
<li>当开启ASLR保护时，start_brk以及brk也会指向同一位置，只是这个位置是在data/bss段结尾后的<strong>随机偏移处</strong></li>
<li><strong>每个arena中含有多个chunk，这些chunk以链表的形式加以组织</strong></li>
</ol>
</blockquote>
<h2 id="0x01-基础"><a href="#0x01-基础" class="headerlink" title="0x01-基础"></a>0x01-基础</h2><ul>
<li>创建线程 pthread_create()</li>
<li>在新的线程创建之后，可以看到还未调用malloc，thread1的栈空间<strong>已经分配好</strong></li>
<li>同主线程一致，malloc之后，会得到一个<strong>大的arena</strong>，<strong>该线程后续申请堆空间就从剩余部分申请</strong></li>
</ul>
<h2 id="0x02-多Arena管理"><a href="#0x02-多Arena管理" class="headerlink" title="0x02-多Arena管理"></a>0x02-多Arena管理</h2><ul>
<li>并不是每个线程都有自己独立的arena，与处理器的核心个数有关</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For 32 bit systems:</div><div class="line">     Number of arena = 2 * number of cores + 1.</div><div class="line">For 64 bit systems:</div><div class="line">     Number of arena = 8 * number of cores + 1.</div></pre></td></tr></table></figure>
<ul>
<li>多arena管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1= 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？</div><div class="line"></div><div class="line">当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</div><div class="line"></div><div class="line">当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</div><div class="line">1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</div><div class="line"></div><div class="line">2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</div><div class="line"></div><div class="line">3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</div><div class="line"></div><div class="line">这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</div></pre></td></tr></table></figure>
<h2 id="0x03-堆管理中的数据结构"><a href="#0x03-堆管理中的数据结构" class="headerlink" title="0x03-堆管理中的数据结构"></a>0x03-堆管理中的数据结构</h2><p><img src="/Users/linwei/blog/source/_posts/IMG_2491.JPG" alt=""></p>
<ol>
<li>heap_info: 即Heap Header,因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header</li>
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header</li>
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk</li>
</ol>
<h2 id="0x04-note"><a href="#0x04-note" class="headerlink" title="0x04-note"></a>0x04-note</h2><ol>
<li><p>Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p>
</li>
<li><p>不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。</p>
</li>
</ol>
<h2 id="0x05-malloc-state-arena-header-和-heapinfo-heap-header"><a href="#0x05-malloc-state-arena-header-和-heapinfo-heap-header" class="headerlink" title="0x05 malloc_state(arena header) 和 heapinfo(heap header)"></a>0x05 malloc<strong>_state(arena header) 和 heap</strong>info(heap header)</h2><p><img src="http://epo.alicdn.com/image/41u4skqanfb0.png" alt=""><br><img src="http://epo.alicdn.com/image/41u4snuicn70.png" alt=""></p>
<h2 id="0x06-chunk"><a href="#0x06-chunk" class="headerlink" title="0x06-chunk"></a>0x06-chunk</h2><ul>
<li><strong>最终版chunk构造</strong></li>
</ul>
<p><strong>allocated_chunk</strong></p>
<p><img src="http://epo.alicdn.com/image/41u4u4r5kvt0.png" alt=""><br><img src="http://epo.alicdn.com/image/41u4u6t5tnk0.png" alt=""><br><img src="http://security.pingan.com/static/upload/2eb47c85f5a863a5c2904e529c0409a6.png" alt=""></p>
<ol>
<li>prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小</li>
<li>size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">PREV_INUSE(P): 表示前一个chunk是否为allocated。</div><div class="line"></div><div class="line">IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。</div><div class="line"></div><div class="line">NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</div><div class="line">~~~ </div><div class="line"></div><div class="line">3.**TOP_chunk**</div><div class="line"></div><div class="line">当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论哪种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</div><div class="line"></div><div class="line">4.**Last Remainder Chunk**</div><div class="line"></div><div class="line">* 产生</div><div class="line"></div><div class="line">当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</div><div class="line"></div><div class="line">* 作用</div><div class="line"></div><div class="line">此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：**前者分配给用户，剩下的部分放到unsorted bin中**，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，**各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性**</div><div class="line"></div><div class="line"></div><div class="line">## 0x07-Bin管理 ##</div><div class="line"></div><div class="line">之前知道，在free之后，空间并没有回收，而是交给操作系统管理，其实就是交给bin链表处理</div><div class="line"></div><div class="line">* 1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin</div><div class="line"></div><div class="line">* **fastbins**: 这是一个数组，用于记录所有的fast bins；</div><div class="line"></div><div class="line">  **bins**: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是：</div></pre></td></tr></table></figure>
<p>bin 1 为unsorted bin;</p>
<p>bin 2 到63为small bin;</p>
<p>bin 64到126为large bin。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](http://epo.alicdn.com/image/420rbsdeo2o0.png)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 0x08-Fast bin ##</div><div class="line"></div><div class="line">**16-80字节(32位)**   </div><div class="line">**32位下的chunk头8字节，fd，bk8字节(各4✖️8=32)，所以实际可用空间总比整体大小小16字节**</div><div class="line"></div><div class="line">* 特性：</div><div class="line"></div><div class="line">1)fast bin的个数——10个</div><div class="line"></div><div class="line">2)每个fast bin都是一个单链表(只使用fd指针)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbins数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推</div><div class="line"></div><div class="line">3) chunk size：10个fast bin中所包含的fast chunk size是**按照步进8字节**排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此默认情况下大小为16到80字节的chunk被分类到fast chunk。详情如图2-1所示。</div><div class="line"></div><div class="line">4) 不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</div><div class="line"></div><div class="line">5) malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理：</div></pre></td></tr></table></figure></p>
<p>/<em> The maximum fastbin request size we support </em>/</p>
<p>#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</p>
<p>#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1</p>
<p>根据max的定义，可得64位下，(SIZE_SZ就是size_t=8)最大的size就是160字节<br>~~~</p>
<p>6) free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunk-size函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</p>
<p><img src="http://security.pingan.com/static/upload/ed79643b225c1c218b764325c62a1afd.png" alt=""></p>
<p>7） 当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；<strong>否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回</strong></p>
<h2 id="0x09-Unsorted-Bin"><a href="#0x09-Unsorted-Bin" class="headerlink" title="0x09-Unsorted Bin"></a>0x09-Unsorted Bin</h2><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？<strong>这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)</strong>。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p>
<p>Unsorted bin的特性如下：</p>
<p>1) unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p>
<p>2) Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。</p>
<h2 id="0x10—Small-Bin"><a href="#0x10—Small-Bin" class="headerlink" title="0x10—Small Bin"></a>0x10—Small Bin</h2><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</p>
<p>Small bin的特性如下：</p>
<p>1) small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</p>
<p>2) chunk size: 同一个small bin中所有chunk大小是一?样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 62 * 8 = 512字节。</p>
<p>3) 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。</p>
<p>4) malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是<strong>交由unsorted bin处理</strong>，如果unsorted bin也不能处理的话，<strong>glibc malloc就依次遍历后续的所有bins</strong>，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了</p>
<p>5) free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，<strong>最后将新的chunk添加到unsorted bin中</strong></p>
<h2 id="0x11-Large-Bin"><a href="#0x11-Large-Bin" class="headerlink" title="0x11-Large Bin"></a>0x11-Large Bin</h2><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</p>
<p>Large bin的特性如下：</p>
<p>1) large bin的数量：63个。Large bin类似于small bin，<strong>只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围</strong>(特例2) ；<strong>二是large chunk可以添加、删除在large bin的任何一个位置</strong>。</p>
<p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p>
<p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。</p>
<p>2) 合并操作：类似于small bin。</p>
<p>3) malloc(large chunk)操作：</p>
<p>初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</p>
<p>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。<strong>Binmap记录了各个bin中是否为空，通过bitmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存</strong>。</p>
<p>4) Free(large chunk)：类似于small chunk。</p>
<p><img src="http://epo.alicdn.com/image/420rc31ppb10.jpg" alt=""></p>
<p>###0x12-Note</p>
<ol>
<li>都是unsorted-bin 到 各种bin  到  top-bin 的处理顺序</li>
<li>fast-bin都是有一个16字节的差，所以例如40bytes，实际24bytes，但是申请32字节的时候返回的是这个chunk，因为allocted的情况下，没有fd，bk。</li>
</ol>

    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
            <li class="next">
                <a href= "/2018/01/25/堆 ##/" title= 堆漏洞总结 >
                    <span>Next Post</span>
                    <span>堆漏洞总结</span>
                </a>
            </li>
        
        
            <li class="previous">
                <a href= "/2017/09/23/how2heap-serious-1/" title= 'how-heap-serious' >
                    <span>Previous Post</span>
                    <span>'how-heap-serious'</span>
                </a>
            </li>
        
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!--PC版-->

    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="emailto:294199511@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/BOBpen" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title="rss"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">Theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper">
        <div class="toc-catalog">
            CATALOG
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux虚拟内存"><span class="toc-number">1.</span> <span class="toc-text">linux虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux堆"><span class="toc-number">2.</span> <span class="toc-text">Linux堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-基础"><span class="toc-number">3.</span> <span class="toc-text">0x01-基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-多Arena管理"><span class="toc-number">4.</span> <span class="toc-text">0x02-多Arena管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-堆管理中的数据结构"><span class="toc-number">5.</span> <span class="toc-text">0x03-堆管理中的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-note"><span class="toc-number">6.</span> <span class="toc-text">0x04-note</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-malloc-state-arena-header-和-heapinfo-heap-header"><span class="toc-number">7.</span> <span class="toc-text">0x05 malloc_state(arena header) 和 heapinfo(heap header)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-chunk"><span class="toc-number">8.</span> <span class="toc-text">0x06-chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x09-Unsorted-Bin"><span class="toc-number">9.</span> <span class="toc-text">0x09-Unsorted Bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x10—Small-Bin"><span class="toc-number">10.</span> <span class="toc-text">0x10—Small Bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x11-Large-Bin"><span class="toc-number">11.</span> <span class="toc-text">0x11-Large Bin</span></a></li></ol>
    </div>
    
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>Archive</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>Tag</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> Total : 5 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/25</span><a class="archive-post-title" href= "/2018/01/25/堆 ##/" >堆漏洞总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/25</span><a class="archive-post-title" href= "/2018/01/25/堆基础笔记/" >堆基础笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href= "/2017/09/23/how2heap-serious-1/" >'how-heap-serious'</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href= "/2017/09/22/how2heap-serious-2/" >how2heap-unlink</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/21</span><a class="archive-post-title" href= "/2017/09/21/how2heap-unlink/" >how2heap-unlink</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #888; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/'
    }
</script>
    <!-- 不蒜子  -->
    
    <!-- CNZZ统计  -->
    
    </div>
    </body>
</html>


